// This file is auto-generated by @hey-api/openapi-ts

export type NewAdminDto = {
    /**
     * The password of the new admin. It must be a strong password containing at least:
     * - 8 characters
     * - 2 lowercase letters
     * - 2 numbers
     * - 2 symbols
     * - 2 uppercase letters
     */
    password: string;
};

export type HttpException = {
    /**
     * Short description of the HTTP error
     */
    message: string;
    /**
     * The HTTP status code
     */
    statusCode: number;
    /**
     * Name of the HTTP status code
     */
    error?: string;
};

export type NewSessionDto = {
    /**
     * The admin's password.
     */
    password: string;
};

export type SessionToken = {
    /**
     * The admin's session token.
     * Send this in the `Authorization` request header as a bearer token (`Bearer your_token`) for private endpoints.
     */
    token: string;
};

export type StringTranslation = {
    /**
     * String translation in spanish.
     */
    es: string | null;
    /**
     * String translation in english.
     */
    en: string | null;
    /**
     * String translation in portuguese.
     */
    pt: string | null;
};

export type BaseFood = {
    /**
     * The code of the food.
     */
    code: string;
    /**
     * The common name of the food.
     */
    commonName: StringTranslation;
    /**
     * The scientific name of the food.
     */
    scientificName?: string;
    /**
     * The subspecies of the food.
     */
    subspecies?: string;
};

export type NewCommonNameDto = {
    /**
     * The common name in spanish.
     */
    es: string;
    /**
     * The common name in english.
     */
    en?: string;
    /**
     * The common name in portuguese.
     */
    pt?: string;
};

export type IngredientsDto = {
    /**
     * The ingredients in spanish.
     */
    es?: string;
    /**
     * The ingredients in english.
     */
    en?: string;
    /**
     * The ingredients in portuguese.
     */
    pt?: string;
};

export type NewNutrientMeasurementDto = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
};

export type NewBatchFoodDto = {
    code: string;
    /**
     * The common name of the food.
     */
    commonName: NewCommonNameDto;
    /**
     * The ingredients of the food.
     */
    ingredients?: IngredientsDto;
    /**
     * The ID of the food group.
     */
    groupId: number;
    /**
     * The ID of the food type.
     */
    typeId: number;
    /**
     * The ID of the scientific name. Should be provided if `subspeciesId` is present.
     */
    scientificNameId?: number;
    /**
     * The ID of the subspecies.
     */
    subspeciesId?: number;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * An array of origin IDs.
     */
    originIds?: Array<number>;
    /**
     * An array with all the nutrient measurements of the food.
     */
    nutrientMeasurements: Array<NewNutrientMeasurementDto>;
    /**
     * An array with all the LanguaL codes of the food.
     */
    langualCodes: Array<number>;
};

export type NewBatchFoodsArrayDto = {
    /**
     * An array of new batch foods. Each code should be unique.
     */
    foods: Array<NewBatchFoodDto>;
};

export type NutrientMeasurement = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
};

export type MacronutrientMeasurement = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
    /**
     * The components that make up this macronutrient measurement.
     */
    components: Array<NutrientMeasurement>;
};

export type MicronutrientMeasurements = {
    /**
     * An array with all the vitamin measurements.
     */
    vitamins: Array<NutrientMeasurement>;
    /**
     * An array with all the minerals measurements.
     */
    minerals: Array<NutrientMeasurement>;
};

export type GroupedNutrientMeasurements = {
    /**
     * An array with all the energy measurements.
     */
    energy: Array<NutrientMeasurement>;
    /**
     * An array with all the macronutrient measurements.
     */
    macronutrients: Array<MacronutrientMeasurement>;
    /**
     * Object containing all the micronutrient measurements.
     */
    micronutrients: MicronutrientMeasurements;
};

export type FoodWithOnlyMeasurements = {
    /**
     * The nutrient measurements of the food.
     */
    nutrientMeasurements: GroupedNutrientMeasurements;
    /**
     * The code of the food.
     */
    code: string;
    /**
     * The common name of the food.
     */
    commonName: StringTranslation;
};

export type BaseFoodGroup = {
    /**
     * The code of the food group.
     */
    code: string;
    /**
     * The name of the food group.
     */
    name: string;
};

export type BaseFoodType = {
    /**
     * The code of the food type.
     */
    code: string;
    /**
     * The name of the food type.
     */
    name: string;
};

export type FoodOrigin = {
    /**
     * The id of the origin.
     */
    id: number;
    /**
     * The name of the origin.
     */
    name: string;
};

export type LangualCode = {
    /**
     * The ID of the LanguaL code.
     */
    id: number;
    /**
     * The LanguaL code.
     */
    code: string;
    /**
     * The descriptor of the LanguaL code.
     */
    descriptor: string;
};

export type GroupedLangualCode = {
    /**
     * The children of the LanguaL code.
     */
    children: Array<LangualCode>;
    /**
     * The ID of the LanguaL code.
     */
    id: number;
    /**
     * The LanguaL code.
     */
    code: string;
    /**
     * The descriptor of the LanguaL code.
     */
    descriptor: string;
};

export type Reference = {
    /**
     * The code of the reference.
     */
    code: number;
    /**
     * The title of the reference.
     */
    title: string;
    /**
     * The type of the reference.
     */
    type: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * The authors of the reference.
     */
    authors: Array<string>;
    /**
     * The year of the reference.
     */
    year?: number;
    /**
     * Additional information of the reference.
     */
    other?: string;
    /**
     * The volume number. Only present if `type` is "article".
     */
    volume?: number;
    /**
     * The issue number. Only present if `type` is "article".
     */
    issue?: number;
    /**
     * The year of the volume. Only present if `type` is "article".
     */
    volumeYear?: number;
    /**
     * The journal where the reference was published. Only present if `type` is "article".
     */
    journalName?: string;
    /**
     * The starting page of the article. Only present if `type` is "article".
     */
    pageStart?: number;
    /**
     * The ending page of the article. Only present if `type` is "article".
     */
    pageEnd?: number;
    /**
     * The city where the reference was published.
     */
    city?: string;
};

export type Food = {
    /**
     * The ingredients of the food.
     */
    ingredients: StringTranslation;
    /**
     * The group of the food.
     */
    group: BaseFoodGroup;
    /**
     * The type of the food.
     */
    type: BaseFoodType;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * The origins of the food.
     */
    origins: Array<FoodOrigin>;
    /**
     * Array with all the LanguaL codes of the food.
     */
    langualCodes: Array<GroupedLangualCode>;
    /**
     * The nutrient measurements of the food.
     */
    nutrientMeasurements: GroupedNutrientMeasurements;
    /**
     * Array with all the referenced used in the nutrient measurements of the food.
     */
    references: Array<Reference>;
    /**
     * The common name of the food.
     */
    commonName: StringTranslation;
    /**
     * The scientific name of the food.
     */
    scientificName?: string;
    /**
     * The subspecies of the food.
     */
    subspecies?: string;
};

export type NewFoodDto = {
    /**
     * The common name of the food.
     */
    commonName: NewCommonNameDto;
    /**
     * The ingredients of the food.
     */
    ingredients?: IngredientsDto;
    /**
     * The ID of the food group.
     */
    groupId: number;
    /**
     * The ID of the food type.
     */
    typeId: number;
    /**
     * The ID of the scientific name. Should be provided if `subspeciesId` is present.
     */
    scientificNameId?: number;
    /**
     * The ID of the subspecies.
     */
    subspeciesId?: number;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * An array of origin IDs.
     */
    originIds?: Array<number>;
    /**
     * An array with all the nutrient measurements of the food.
     */
    nutrientMeasurements: Array<NewNutrientMeasurementDto>;
    /**
     * An array with all the LanguaL codes of the food.
     */
    langualCodes: Array<number>;
};

export type CommonNameUpdateDto = {
    /**
     * The common name in spanish.
     */
    es?: string;
    /**
     * The common name in english.
     */
    en?: string;
    /**
     * The common name in portuguese.
     */
    pt?: string;
};

export type NutrientMeasurementUpdateDto = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average?: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType?: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
};

export type FoodUpdateDto = {
    /**
     * The common name of the food.
     */
    commonName?: CommonNameUpdateDto;
    /**
     * The ingredients of the food.
     */
    ingredients?: IngredientsDto;
    /**
     * The ID of the food group.
     */
    groupId?: number;
    /**
     * The ID of the food type.
     */
    typeId?: number;
    /**
     * The ID of the scientific name.
     */
    scientificNameId?: number;
    /**
     * The ID of the subspecies.
     */
    subspeciesId?: number;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * An array of origin IDs.
     */
    originIds?: Array<number>;
    /**
     * An array of nutrient measurements of the food.
     */
    nutrientMeasurements?: Array<NutrientMeasurementUpdateDto>;
    /**
     * An array of LanguaL codes of the food.
     */
    langualCodes?: Array<number>;
};

export type FoodGroup = {
    /**
     * The code of the food group.
     */
    code: string;
    /**
     * The name of the food group.
     */
    name: string;
    /**
     * The id of the food group.
     */
    id: number;
};

export type NewGroupDto = {
    /**
     * The code of the food group.
     */
    code: string;
    /**
     * The name of the food group.
     */
    name: string;
};

export type Nutrient = {
    /**
     * The ID of the nutrient.
     */
    id: number;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
};

export type Macronutrient = {
    /**
     * The ID of the nutrient.
     */
    id: number;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
    /**
     * The nutrients that make up this macronutrient.
     */
    components: Array<Nutrient>;
};

export type Micronutrients = {
    /**
     * An array with all the vitamins.
     */
    vitamins: Array<Nutrient>;
    /**
     * An array with all the minerals.
     */
    minerals: Array<Nutrient>;
};

export type GroupedNutrients = {
    /**
     * An array with all the energy nutrients.
     */
    energy: Array<Nutrient>;
    /**
     * An array with all the macronutrients.
     */
    macronutrients: Array<Macronutrient>;
    /**
     * Object containing all the micronutrients.
     */
    micronutrients: Micronutrients;
};

export type NewNutrientDto = {
    /**
     * The type of the nutrient.
     */
    type: 'energy' | 'macronutrient' | 'component' | 'micronutrient';
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized?: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
    /**
     * The ID of the macronutrient associated with this nutrient.
     * Should only be provided if the `type` is "component".
     */
    macronutrientId?: number;
    /**
     * The type of micronutrient, if applicable.
     * Should only be provided if the `type` is "micronutrient".
     */
    micronutrientType?: 'vitamin' | 'mineral';
};

export type Origin = {
    /**
     * The ID of the parent origin. Not present if the `type` is "region".
     */
    parentId?: number;
    /**
     * The number of the region (1-indexed).
     */
    regionNumber?: number;
    /**
     * The place of the origin from north to south (0-indexed).
     */
    regionPlace?: number;
    /**
     * The type of the location. Only present if `type` is "location".
     */
    locationType?: 'city' | 'town';
    /**
     * The id of the origin.
     */
    id: number;
    /**
     * The type of the origin.
     */
    type: 'region' | 'province' | 'commune' | 'location';
    /**
     * The name of the origin.
     */
    name: string;
};

export type NewOriginDto = {
    /**
     * The name of the origin.
     */
    name: string;
    /**
     * The type of the origin.
     */
    type: 'region' | 'province' | 'commune' | 'location';
    /**
     * The ID of the parent origin. Should only be provided if `type` is not "region".
     */
    parentId?: number;
    /**
     * The region number. Should only be provided if `type` is "region".
     */
    regionNumber?: number;
    /**
     * The region place. Should only be provided if `type` is "region".
     */
    regionPlace?: number;
    /**
     * The type of the location. Should only be provided if `type` is "location".
     */
    locationType?: 'city' | 'town';
};

export type OriginWithoutId = {
    /**
     * The type of the origin.
     */
    type: 'region' | 'province' | 'commune' | 'location';
    /**
     * The name of the origin.
     */
    name: string;
    /**
     * The ID of the parent origin. Not present if the `type` is "region".
     */
    parentId?: number;
    /**
     * The number of the region (1-indexed).
     */
    regionNumber?: number;
    /**
     * The place of the origin from north to south (0-indexed).
     */
    regionPlace?: number;
    /**
     * The type of the location. Only present if `type` is "location".
     */
    locationType?: 'city' | 'town';
};

export type OriginChild = {
    /**
     * The ID of the child origin.
     */
    id: number;
    /**
     * The name of the child origin.
     */
    name: string;
    /**
     * The location type of the child origin.
     * Only present if the child origin type is "location", i.e. parent type is "commune".
     */
    type?: 'city' | 'town';
};

export type NewVolumeDto = {
    /**
     * The volume number.
     */
    volume: number;
    /**
     * The issue number.
     */
    issue: number;
    /**
     * The year of the volume.
     */
    year: number;
    /**
     * The ID of the journal. Should not be provided if `newJournal` is present.
     */
    journalId?: number;
    /**
     * The name of the new journal. Should not be provided if `journalId` is present.
     */
    newJournal?: string;
};

export type NewArticleDto = {
    /**
     * The starting page of the article.
     */
    pageStart: number;
    /**
     * The ending page of the article.
     */
    pageEnd: number;
    /**
     * The ID of the volume. Should not be provided if `newVolume` is present.
     */
    volumeId?: number;
    /**
     * The DTO for creating a new volume. Should not be provided if `volumeId` is present.
     */
    newVolume?: NewVolumeDto;
};

export type NewBatchReferenceDto = {
    /**
     * The code of the reference.
     */
    code: number;
    /**
     * The type of the reference.
     */
    type: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * The title of the reference.
     */
    title: string;
    /**
     * An array of author IDs. The length of this combined with `newAuthors` should be at least 1.
     */
    authorIds?: Array<number>;
    /**
     * An array of new author names.  The length of this combined with `authorIds` should be at least 1.
     */
    newAuthors?: Array<string>;
    /**
     * The year of the reference.
     */
    year?: number;
    /**
     * The DTO for creating a new article. Should only be provided if `type` is "article".
     */
    newArticle?: NewArticleDto;
    /**
     * The ID of the city. Should not be provided if `newCity` is present.
     */
    cityId?: number;
    /**
     * The name of the new city. Should not be provided if `cityId` is present.
     */
    newCity?: string;
    /**
     * Additional information required for website or book references. May be specified for other types as well.
     */
    other?: string;
};

export type NewBatchReferencesArrayDto = {
    /**
     * An array of new references. Codes and articles may not be repeated.
     */
    references: Array<NewBatchReferenceDto>;
};

export type NewReferenceDto = {
    /**
     * The type of the reference.
     */
    type: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * The title of the reference.
     */
    title: string;
    /**
     * An array of author IDs. The length of this combined with `newAuthors` should be at least 1.
     */
    authorIds?: Array<number>;
    /**
     * An array of new author names.  The length of this combined with `authorIds` should be at least 1.
     */
    newAuthors?: Array<string>;
    /**
     * The year of the reference.
     */
    year?: number;
    /**
     * The DTO for creating a new article. Should only be provided if `type` is "article".
     */
    newArticle?: NewArticleDto;
    /**
     * The ID of the city. Should not be provided if `newCity` is present.
     */
    cityId?: number;
    /**
     * The name of the new city. Should not be provided if `cityId` is present.
     */
    newCity?: string;
    /**
     * Additional information required for website or book references. May be specified for other types as well.
     */
    other?: string;
};

export type Author = {
    /**
     * The ID of the author.
     */
    id: number;
    /**
     * The name of the author.
     */
    name: string;
};

export type City = {
    /**
     * The ID of the city.
     */
    id: number;
    /**
     * The name of the city.
     */
    name: string;
};

export type Article = {
    /**
     * The ID of the author.
     */
    id: number;
    /**
     * The ID of the volume.
     */
    volumeId: number;
    /**
     * The starting page of the article.
     */
    pageStart: number;
    /**
     * The ending page of the article.
     */
    pageEnd: number;
};

export type JournalVolume = {
    /**
     * The ID of the author.
     */
    id: number;
    /**
     * The ID of the journal.
     */
    journalId: number;
    /**
     * The volume number.
     */
    volume: number;
    /**
     * The issue number.
     */
    issue: number;
    /**
     * The year of the volume.
     */
    year: number;
};

export type Journal = {
    /**
     * The ID of the journal.
     */
    id: number;
    /**
     * The name of the journal.
     */
    name: string;
};

export type ScientificName = {
    /**
     * The id of the scientific name.
     */
    id: number;
    /**
     * The scientific name.
     */
    name: string;
};

export type NewScientificNameDto = {
    /**
     * The name of the scientific entity.
     */
    name: string;
};

export type Subspecies = {
    /**
     * The id of the subspecies.
     */
    id: number;
    /**
     * The name of the subspecies.
     */
    name: string;
};

export type NewSubspeciesDto = {
    /**
     * The name of the subspecies.
     */
    name: string;
};

export type FoodType = {
    /**
     * The code of the food type.
     */
    code: string;
    /**
     * The name of the food type.
     */
    name: string;
    /**
     * The id of the food type.
     */
    id: number;
};

export type NewTypeDto = {
    /**
     * The code of the food type.
     */
    code: string;
    /**
     * The name of the food type.
     */
    name: string;
};

export type Language = {
    /**
     * The ID of the language.
     */
    id: number;
    /**
     * The code of the language.
     */
    code: 'es' | 'en' | 'pt';
    /**
     * The name of the language.
     */
    name: string;
};

export type XlsxFileDto = {
    file: Blob | File;
};

export type XlsxStringValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: string | null;
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: string | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxStringTranslation = {
    /**
     * String translation in spanish.
     */
    es: XlsxStringValue | null;
    /**
     * String translation in english.
     */
    en: XlsxStringValue | null;
    /**
     * String translation in portuguese.
     */
    pt: XlsxStringValue | null;
};

export type XlsxNumberValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: number | null;
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: number | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxMeasurementDataTypeValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: string | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxNutrientMeasurement = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: XlsxNumberValue;
    /**
     * The deviation value of the measurement.
     */
    deviation?: XlsxNumberValue;
    /**
     * The minimum value of the measurement.
     */
    min?: XlsxNumberValue;
    /**
     * The maximum value of the measurement.
     */
    max?: XlsxNumberValue;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: XlsxNumberValue;
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<XlsxNumberValue>;
    /**
     * The data type of the measurement.
     */
    dataType: XlsxMeasurementDataTypeValue;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxFood = {
    /**
     * The code of the food.
     */
    code: XlsxStringValue;
    /**
     * The common name of the food.
     */
    commonName: XlsxStringTranslation;
    /**
     * The ingredients of the food.
     */
    ingredients: XlsxStringTranslation;
    /**
     * The group of the food.
     */
    group: XlsxNumberValue;
    /**
     * The type of the food.
     */
    type: XlsxNumberValue;
    /**
     * The scientific name of the food.
     */
    scientificName?: XlsxNumberValue;
    /**
     * The subspecies of the food.
     */
    subspecies?: XlsxNumberValue;
    /**
     * The strain of the food.
     */
    strain?: XlsxStringValue;
    /**
     * The brand of the food.
     */
    brand?: XlsxStringValue;
    /**
     * The origins of the food.
     */
    origins: Array<XlsxNumberValue>;
    /**
     * Any additional observations about the food.
     */
    observation?: XlsxStringValue;
    /**
     * Array with all the LanguaL codes of the food.
     */
    langualCodes: Array<XlsxNumberValue>;
    /**
     * The nutrient measurements of the food.
     */
    nutrientMeasurements: Array<XlsxNutrientMeasurement>;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxReferenceTypeValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: string | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxReference = {
    /**
     * The code of the reference.
     */
    code: XlsxNumberValue;
    /**
     * The title of the reference.
     */
    title: XlsxStringValue;
    /**
     * The type of the reference.
     */
    type: XlsxReferenceTypeValue;
    /**
     * The authors of the reference.
     */
    authors: Array<XlsxNumberValue>;
    /**
     * The year of the reference.
     */
    year?: XlsxNumberValue;
    /**
     * Additional information of the reference.
     */
    other?: XlsxStringValue;
    /**
     * The volume number.
     */
    volume?: XlsxNumberValue;
    /**
     * The issue number.
     */
    issue?: XlsxNumberValue;
    /**
     * The year of the volume.
     */
    volumeYear?: XlsxNumberValue;
    /**
     * The journal where the reference was published.
     */
    journal?: XlsxNumberValue;
    /**
     * The starting page of the article.
     */
    pageStart?: XlsxNumberValue;
    /**
     * The ending page of the article.
     */
    pageEnd?: XlsxNumberValue;
    /**
     * The city where the reference was published.
     */
    city?: XlsxNumberValue;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type ParseXlsxResult = {
    /**
     * Array with all the foods parsed from the XLS(X) file.
     */
    foods: Array<XlsxFood>;
    /**
     * Array with all the foods parsed from the XLS(X) file.
     */
    references: Array<XlsxReference>;
};

export type DeleteAdminV1Data = {
    body?: never;
    path: {
        /**
         * The username of the admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}';
};

export type DeleteAdminV1Errors = {
    /**
     * Validation errors (params).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type DeleteAdminV1Error = DeleteAdminV1Errors[keyof DeleteAdminV1Errors];

export type DeleteAdminV1Responses = {
    /**
     * Admin deleted successfully.
     */
    204: void;
};

export type DeleteAdminV1Response = DeleteAdminV1Responses[keyof DeleteAdminV1Responses];

export type CreateAdminV1Data = {
    body: NewAdminDto;
    path: {
        /**
         * The username of the new admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}';
};

export type CreateAdminV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Admin already exists.
     */
    409: HttpException;
};

export type CreateAdminV1Error = CreateAdminV1Errors[keyof CreateAdminV1Errors];

export type CreateAdminV1Responses = {
    /**
     * Admin created successfully.
     */
    201: unknown;
};

export type DeleteSessionV1Data = {
    body?: never;
    path: {
        /**
         * The username of the admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}/session';
};

export type DeleteSessionV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type DeleteSessionV1Error = DeleteSessionV1Errors[keyof DeleteSessionV1Errors];

export type DeleteSessionV1Responses = {
    /**
     * Session token deleted successfully.
     */
    204: void;
};

export type DeleteSessionV1Response = DeleteSessionV1Responses[keyof DeleteSessionV1Responses];

export type GetSessionV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/admins/{username}/session';
};

export type GetSessionV1Errors = {
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
};

export type GetSessionV1Error = GetSessionV1Errors[keyof GetSessionV1Errors];

export type GetSessionV1Responses = {
    /**
     * Session token validated successfully.
     */
    200: unknown;
};

export type CreateSessionV1Data = {
    body: NewSessionDto;
    path: {
        /**
         * The username of the admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}/session';
};

export type CreateSessionV1Errors = {
    /**
     * Validation errors (params or body).
     */
    400: HttpException;
    /**
     * Password is incorrect.
     */
    401: HttpException;
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type CreateSessionV1Error = CreateSessionV1Errors[keyof CreateSessionV1Errors];

export type CreateSessionV1Responses = {
    /**
     * Session token created successfully.
     */
    201: SessionToken;
};

export type CreateSessionV1Response = CreateSessionV1Responses[keyof CreateSessionV1Responses];

export type GetFoodsV1Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the food.
         */
        name?: string;
        /**
         * An array of region IDs.
         */
        regions?: Array<number>;
        /**
         * An array of group IDs.
         */
        groups?: Array<number>;
        /**
         * An array of type IDs.
         */
        types?: Array<number>;
        /**
         * An array of nutrient IDs.
         */
        nutrients?: Array<number>;
        /**
         * An array of comparison operators.
         */
        operators?: Array<'<' | '<=' | '=' | '>=' | '>'>;
        /**
         * An array of values for nutrient filters.
         */
        values?: Array<number>;
    };
    url: '/foods';
};

export type GetFoodsV1Errors = {
    /**
     * <br/>Either one of the following:<br/>– Some regions don't exist.<br/>– Some food groups don't exist.<br/>– Some food types don't exist.<br/>– Some nutrients don't exist.<br/>
     */
    404: HttpException;
};

export type GetFoodsV1Error = GetFoodsV1Errors[keyof GetFoodsV1Errors];

export type GetFoodsV1Responses = {
    /**
     * Successfully retrieved foods.
     */
    200: Array<BaseFood>;
};

export type GetFoodsV1Response = GetFoodsV1Responses[keyof GetFoodsV1Responses];

export type BatchCreateFoodsV1Data = {
    body: NewBatchFoodsArrayDto;
    path?: never;
    query?: never;
    url: '/foods';
};

export type BatchCreateFoodsV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>– Food group doesn't exist.<br/>– Food type doesn't exist.<br/>– Scientific name doesn't exist.<br/>– Subspecies doesn't exist.<br/>– Some origins don't exist.<br/>– Some LanguaL codes don't exist.<br/>– Nutrient doesn't exist.<br/>– Some references don't exist.<br/>
     */
    404: HttpException;
    /**
     * Food already exists.
     */
    409: HttpException;
};

export type BatchCreateFoodsV1Error = BatchCreateFoodsV1Errors[keyof BatchCreateFoodsV1Errors];

export type BatchCreateFoodsV1Responses = {
    /**
     * Foods created successfully.
     */
    201: unknown;
};

export type CompareFoodsV1Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of food codes.
         */
        codes?: Array<string>;
    };
    url: '/foods/compare';
};

export type CompareFoodsV1Responses = {
    200: Array<FoodWithOnlyMeasurements>;
};

export type CompareFoodsV1Response = CompareFoodsV1Responses[keyof CompareFoodsV1Responses];

export type GetFoodV1Data = {
    body?: never;
    path: {
        /**
         * The code of the food.
         */
        code: string;
    };
    query?: never;
    url: '/foods/{code}';
};

export type GetFoodV1Errors = {
    /**
     * Food doesn't exist.
     */
    404: HttpException;
};

export type GetFoodV1Error = GetFoodV1Errors[keyof GetFoodV1Errors];

export type GetFoodV1Responses = {
    /**
     * Successfully retrieved food.
     */
    200: Food;
};

export type GetFoodV1Response = GetFoodV1Responses[keyof GetFoodV1Responses];

export type UpdateFoodV1Data = {
    body: FoodUpdateDto;
    path: {
        /**
         * The code of the food.
         */
        code: string;
    };
    query?: never;
    url: '/foods/{code}';
};

export type UpdateFoodV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Food doesn't exist.<br/>- Food group doesn't exist.<br/>- Food type doesn't exist.<br/>- Scientific name doesn't exist.<br/>- Subspecies doesn't exist.<br/>- Some origins don't exist.<br/>- Some LanguaL codes don't exist.<br/>- Nutrient doesn't exist.<br/>- Some references don't exist.<br/>
     */
    404: HttpException;
};

export type UpdateFoodV1Error = UpdateFoodV1Errors[keyof UpdateFoodV1Errors];

export type UpdateFoodV1Responses = {
    /**
     * Food updated successfully.
     */
    200: unknown;
};

export type CreateFoodV1Data = {
    body: NewFoodDto;
    path: {
        /**
         * The code of the new food.
         */
        code: string;
    };
    query?: never;
    url: '/foods/{code}';
};

export type CreateFoodV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Food group doesn't exist.<br/>- Food type doesn't exist.<br/>- Scientific name doesn't exist.<br/>- Subspecies doesn't exist.<br/>- Some origins don't exist.<br/>- Some LanguaL codes don't exist.<br/>- Nutrient doesn't exist.<br/>- Some references don't exist.<br/>
     */
    404: HttpException;
    /**
     * Food already exists.
     */
    409: HttpException;
};

export type CreateFoodV1Error = CreateFoodV1Errors[keyof CreateFoodV1Errors];

export type CreateFoodV1Responses = {
    /**
     * Food created successfully.
     */
    201: unknown;
};

export type GetFoodGroupsV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/groups';
};

export type GetFoodGroupsV1Responses = {
    /**
     * Successfully retrieved food groups.
     */
    200: Array<FoodGroup>;
};

export type GetFoodGroupsV1Response = GetFoodGroupsV1Responses[keyof GetFoodGroupsV1Responses];

export type CreateFoodGroupV1Data = {
    body: NewGroupDto;
    path?: never;
    query?: never;
    url: '/groups';
};

export type CreateFoodGroupV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Food group already exists.
     */
    409: HttpException;
};

export type CreateFoodGroupV1Error = CreateFoodGroupV1Errors[keyof CreateFoodGroupV1Errors];

export type CreateFoodGroupV1Responses = {
    /**
     * Food group created successfully.
     */
    201: unknown;
};

export type GetLangualCodesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/langual-codes';
};

export type GetLangualCodesV1Responses = {
    /**
     * Successfully retrieved LanguaL codes.
     */
    200: Array<LangualCode>;
};

export type GetLangualCodesV1Response = GetLangualCodesV1Responses[keyof GetLangualCodesV1Responses];

export type GetGroupedLangualCodesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/langual-codes/grouped';
};

export type GetGroupedLangualCodesV1Responses = {
    /**
     * Successfully retrieved LanguaL codes grouped by parent.
     */
    200: Array<GroupedLangualCode>;
};

export type GetGroupedLangualCodesV1Response = GetGroupedLangualCodesV1Responses[keyof GetGroupedLangualCodesV1Responses];

export type GetNutrientsV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/nutrients';
};

export type GetNutrientsV1Responses = {
    /**
     * Successfully retrieved nutrients.
     */
    200: GroupedNutrients;
};

export type GetNutrientsV1Response = GetNutrientsV1Responses[keyof GetNutrientsV1Responses];

export type CreateNutrientV1Data = {
    body: NewNutrientDto;
    path?: never;
    query?: never;
    url: '/nutrients';
};

export type CreateNutrientV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Macronutrient doesn't exist.
     */
    404: HttpException;
    /**
     * Nutrient already exists.
     */
    409: HttpException;
};

export type CreateNutrientV1Error = CreateNutrientV1Errors[keyof CreateNutrientV1Errors];

export type CreateNutrientV1Responses = {
    /**
     * Nutrient created successfully.
     */
    201: unknown;
};

export type GetOriginsV1Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the origin.
         */
        name?: string;
    };
    url: '/origins';
};

export type GetOriginsV1Responses = {
    /**
     * Successfully retrieved origins.
     */
    200: Array<Origin>;
};

export type GetOriginsV1Response = GetOriginsV1Responses[keyof GetOriginsV1Responses];

export type CreateOriginV1Data = {
    body: NewOriginDto;
    path?: never;
    query?: never;
    url: '/origins';
};

export type CreateOriginV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Parent origin doesn't exist.
     */
    404: HttpException;
    /**
     * Origin already exists.
     */
    409: HttpException;
};

export type CreateOriginV1Error = CreateOriginV1Errors[keyof CreateOriginV1Errors];

export type CreateOriginV1Responses = {
    /**
     * Origin created successfully.
     */
    201: unknown;
};

export type GetOriginV1Data = {
    body?: never;
    path: {
        /**
         * The ID of the origin.
         */
        id: number;
    };
    query?: never;
    url: '/origins/{id}';
};

export type GetOriginV1Errors = {
    /**
     * Validation errors (params).
     */
    400: HttpException;
    /**
     * Origin doesn't exist.
     */
    404: HttpException;
};

export type GetOriginV1Error = GetOriginV1Errors[keyof GetOriginV1Errors];

export type GetOriginV1Responses = {
    /**
     * Successfully retrieved origin.
     */
    200: OriginWithoutId;
};

export type GetOriginV1Response = GetOriginV1Responses[keyof GetOriginV1Responses];

export type GetOriginChildrenV1Data = {
    body?: never;
    path: {
        /**
         * The ID of the origin.
         */
        id: number;
    };
    query?: never;
    url: '/origins/{id}/children';
};

export type GetOriginChildrenV1Errors = {
    /**
     * Validation errors (params).
     */
    400: HttpException;
    /**
     * Origin doesn't exist.
     */
    404: HttpException;
};

export type GetOriginChildrenV1Error = GetOriginChildrenV1Errors[keyof GetOriginChildrenV1Errors];

export type GetOriginChildrenV1Responses = {
    /**
     * Successfully retrieved origin children.
     */
    200: Array<OriginChild>;
};

export type GetOriginChildrenV1Response = GetOriginChildrenV1Responses[keyof GetOriginChildrenV1Responses];

export type GetReferencesV1Data = {
    body?: never;
    path?: never;
    query: {
        /**
         * The title of the reference.
         */
        title?: string;
        /**
         * An array of author IDs.
         */
        authors: Array<number>;
        /**
         * An array of journal IDs.
         */
        journals: Array<number>;
        /**
         * An array of city IDs.
         */
        cities: Array<number>;
    };
    url: '/references';
};

export type GetReferencesV1Errors = {
    /**
     * Validation errors (query).
     */
    400: HttpException;
    /**
     * <br/>Either one of the following:<br/>– Some authors don't exist.<br/>– Some cities don't exist.<br/>– Some journals don't exist.<br/>
     */
    404: HttpException;
};

export type GetReferencesV1Error = GetReferencesV1Errors[keyof GetReferencesV1Errors];

export type GetReferencesV1Responses = {
    /**
     * Successfully retrieved references.
     */
    200: Array<Reference>;
};

export type GetReferencesV1Response = GetReferencesV1Responses[keyof GetReferencesV1Responses];

export type BatchCreateReferencesV1Data = {
    body: NewBatchReferencesArrayDto;
    path?: never;
    query?: never;
    url: '/references';
};

export type BatchCreateReferencesV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Some authors don't exist.<br/>- City doesn't exist.<br/>- Volume doesn't exist.<br/>- Journal doesn't exist.<br/>
     */
    404: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Reference already exists.<br/>- Some authors already exist.<br/>- City already exists.<br/>- Volume already exists.<br/>- Journal already exists.<br/>
     */
    409: HttpException;
};

export type BatchCreateReferencesV1Error = BatchCreateReferencesV1Errors[keyof BatchCreateReferencesV1Errors];

export type BatchCreateReferencesV1Responses = {
    /**
     * References created successfully.
     */
    201: unknown;
};

export type CreateReferenceV1Data = {
    body: NewReferenceDto;
    path: {
        /**
         * The code of the reference.
         */
        code: number;
    };
    query?: never;
    url: '/references/{code}';
};

export type CreateReferenceV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Some authors don't exist.<br/>- City doesn't exist.<br/>- Volume doesn't exist.<br/>- Journal doesn't exist.<br/>
     */
    404: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Reference already exists.<br/>- Some authors already exist.<br/>- City already exists.<br/>- Volume already exists.<br/>- Journal already exists.<br/>
     */
    409: HttpException;
};

export type CreateReferenceV1Error = CreateReferenceV1Errors[keyof CreateReferenceV1Errors];

export type CreateReferenceV1Responses = {
    /**
     * Reference created successfully.
     */
    201: unknown;
};

export type GetAuthorsV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/authors';
};

export type GetAuthorsV1Responses = {
    /**
     * Successfully retrieved authors.
     */
    200: Array<Author>;
};

export type GetAuthorsV1Response = GetAuthorsV1Responses[keyof GetAuthorsV1Responses];

export type GetCitiesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/cities';
};

export type GetCitiesV1Responses = {
    /**
     * Successfully retrieved cities.
     */
    200: Array<City>;
};

export type GetCitiesV1Response = GetCitiesV1Responses[keyof GetCitiesV1Responses];

export type GetArticlesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/articles';
};

export type GetArticlesV1Responses = {
    200: Array<Article>;
};

export type GetArticlesV1Response = GetArticlesV1Responses[keyof GetArticlesV1Responses];

export type GetJournalVolumesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/journal-volumes';
};

export type GetJournalVolumesV1Responses = {
    200: Array<JournalVolume>;
};

export type GetJournalVolumesV1Response = GetJournalVolumesV1Responses[keyof GetJournalVolumesV1Responses];

export type GetJournalsV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/journals';
};

export type GetJournalsV1Responses = {
    /**
     * Successfully retrieved journals.
     */
    200: Array<Journal>;
};

export type GetJournalsV1Response = GetJournalsV1Responses[keyof GetJournalsV1Responses];

export type GetScientificNamesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/scientific-names';
};

export type GetScientificNamesV1Responses = {
    /**
     * Successfully retrieved scientific names.
     */
    200: Array<ScientificName>;
};

export type GetScientificNamesV1Response = GetScientificNamesV1Responses[keyof GetScientificNamesV1Responses];

export type CreateScientificNameV1Data = {
    body: NewScientificNameDto;
    path?: never;
    query?: never;
    url: '/scientific-names';
};

export type CreateScientificNameV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Scientific name already exists.
     */
    409: HttpException;
};

export type CreateScientificNameV1Error = CreateScientificNameV1Errors[keyof CreateScientificNameV1Errors];

export type CreateScientificNameV1Responses = {
    /**
     * Scientific name created successfully.
     */
    201: unknown;
};

export type GetSubspeciesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/subspecies';
};

export type GetSubspeciesV1Responses = {
    /**
     * Successfully retrieved subspecies.
     */
    200: Array<Subspecies>;
};

export type GetSubspeciesV1Response = GetSubspeciesV1Responses[keyof GetSubspeciesV1Responses];

export type CreateSubspeciesV1Data = {
    body: NewSubspeciesDto;
    path?: never;
    query?: never;
    url: '/subspecies';
};

export type CreateSubspeciesV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Subspecies already exists.
     */
    409: HttpException;
};

export type CreateSubspeciesV1Error = CreateSubspeciesV1Errors[keyof CreateSubspeciesV1Errors];

export type CreateSubspeciesV1Responses = {
    /**
     * Subspecies created successfully.
     */
    201: unknown;
};

export type GetFoodTypesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/types';
};

export type GetFoodTypesV1Responses = {
    /**
     * Successfully retrieved food types.
     */
    200: Array<FoodType>;
};

export type GetFoodTypesV1Response = GetFoodTypesV1Responses[keyof GetFoodTypesV1Responses];

export type CreateFoodTypeV1Data = {
    body: NewTypeDto;
    path?: never;
    query?: never;
    url: '/types';
};

export type CreateFoodTypeV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Food type already exists.
     */
    409: HttpException;
};

export type CreateFoodTypeV1Error = CreateFoodTypeV1Errors[keyof CreateFoodTypeV1Errors];

export type CreateFoodTypeV1Responses = {
    /**
     * Food type created successfully.
     */
    201: unknown;
};

export type GetLanguagesV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/languages';
};

export type GetLanguagesV1Responses = {
    /**
     * Successfully retrieved languages.
     */
    200: Array<Language>;
};

export type GetLanguagesV1Response = GetLanguagesV1Responses[keyof GetLanguagesV1Responses];

export type GetXlsxV1Data = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of food codes.
         */
        codes?: Array<string>;
        /**
         * The language in which to get the food data.
         */
        lang?: 'es' | 'en' | 'pt';
    };
    url: '/xlsx';
};

export type GetXlsxV1Errors = {
    /**
     * Validation errors (query).
     */
    400: HttpException;
};

export type GetXlsxV1Error = GetXlsxV1Errors[keyof GetXlsxV1Errors];

export type GetXlsxV1Responses = {
    /**
     * XLSX file with food and references
     */
    200: unknown;
};

export type ParseXlsxV1Data = {
    /**
     * The XLS(X) file.
     */
    body: XlsxFileDto;
    path?: never;
    query?: never;
    url: '/xlsx';
};

export type ParseXlsxV1Errors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
};

export type ParseXlsxV1Error = ParseXlsxV1Errors[keyof ParseXlsxV1Errors];

export type ParseXlsxV1Responses = {
    /**
     * Parsed XLS(X) file contents successfully.
     */
    200: ParseXlsxResult;
    /**
     * *Never returned. Automatically generated by Swagger.*
     */
    201: unknown;
};

export type ParseXlsxV1Response = ParseXlsxV1Responses[keyof ParseXlsxV1Responses];

export type ClientOptions = {
    baseUrl: `${string}://api` | (string & {});
};