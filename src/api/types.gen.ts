// This file is auto-generated by @hey-api/openapi-ts

export type AdminCredentialsDto = {
    /**
     * The admin's username.
     */
    username: string;
    /**
     * The admin's password.
     */
    password: string;
};

export type HttpException = {
    /**
     * Short description of the HTTP error
     */
    message: string;
    /**
     * The HTTP status code
     */
    statusCode: number;
    /**
     * Name of the HTTP status code
     */
    error?: string;
};

export type SessionInfo = {
    /**
     * The username of the currently logged-in admin.
     */
    username: string;
};

export type NewAdminDto = {
    /**
     * The password of the new admin. It must be a strong password containing at least:
     * - 8 characters
     * - 2 lowercase letters
     * - 2 numbers
     * - 2 symbols
     * - 2 uppercase letters
     */
    password: string;
};

export type NewSessionDto = {
    /**
     * The admin's password.
     */
    password: string;
};

export type SessionToken = {
    /**
     * The admin's session token.
     * Send this in the `Authorization` request header as a bearer token (`Bearer your_token`) for private endpoints.
     */
    token: string;
};

export type StringTranslation = {
    /**
     * String translation in spanish.
     */
    es: string | null;
    /**
     * String translation in english.
     */
    en: string | null;
    /**
     * String translation in portuguese.
     */
    pt: string | null;
};

export type BaseFood = {
    /**
     * The code of the food.
     */
    code: string;
    /**
     * The common name of the food.
     */
    commonName: StringTranslation;
    /**
     * The scientific name of the food.
     */
    scientificName?: string;
    /**
     * The subspecies of the food.
     */
    subspecies?: string;
};

export type NewCommonNameDto = {
    /**
     * The common name in spanish.
     */
    es: string;
    /**
     * The common name in english.
     */
    en?: string;
    /**
     * The common name in portuguese.
     */
    pt?: string;
};

export type IngredientsDto = {
    /**
     * The ingredients in spanish.
     */
    es?: string;
    /**
     * The ingredients in english.
     */
    en?: string;
    /**
     * The ingredients in portuguese.
     */
    pt?: string;
};

export type NewNutrientMeasurementDto = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
};

export type NewBatchFoodDto = {
    code: string;
    /**
     * The common name of the food.
     */
    commonName: NewCommonNameDto;
    /**
     * The ingredients of the food.
     */
    ingredients?: IngredientsDto;
    /**
     * The ID of the food group.
     */
    groupId: number;
    /**
     * The ID of the food type.
     */
    typeId: number;
    /**
     * The ID of the scientific name. Should be provided if `subspeciesId` is present.
     */
    scientificNameId?: number;
    /**
     * The ID of the subspecies.
     */
    subspeciesId?: number;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * An array of origin IDs.
     */
    originIds?: Array<number>;
    /**
     * An array with all the nutrient measurements of the food.
     */
    nutrientMeasurements: Array<NewNutrientMeasurementDto>;
    /**
     * An array with all the LanguaL codes of the food.
     */
    langualCodes: Array<number>;
};

export type NewBatchFoodsArrayDto = {
    /**
     * An array of new batch foods. Each code should be unique.
     */
    foods: Array<NewBatchFoodDto>;
};

export type NutrientMeasurement = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
};

export type MacronutrientMeasurement = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
    /**
     * The components that make up this macronutrient measurement.
     */
    components: Array<NutrientMeasurement>;
};

export type MicronutrientMeasurements = {
    /**
     * An array with all the vitamin measurements.
     */
    vitamins: Array<NutrientMeasurement>;
    /**
     * An array with all the minerals measurements.
     */
    minerals: Array<NutrientMeasurement>;
};

export type GroupedNutrientMeasurements = {
    /**
     * An array with all the energy measurements.
     */
    energy: Array<NutrientMeasurement>;
    /**
     * An array with all the macronutrient measurements.
     */
    macronutrients: Array<MacronutrientMeasurement>;
    /**
     * Object containing all the micronutrient measurements.
     */
    micronutrients: MicronutrientMeasurements;
};

export type FoodWithOnlyMeasurements = {
    /**
     * The nutrient measurements of the food.
     */
    nutrientMeasurements: GroupedNutrientMeasurements;
    /**
     * The code of the food.
     */
    code: string;
    /**
     * The common name of the food.
     */
    commonName: StringTranslation;
};

export type BaseFoodGroup = {
    /**
     * The code of the food group.
     */
    code: string;
    /**
     * The name of the food group.
     */
    name: string;
};

export type BaseFoodType = {
    /**
     * The code of the food type.
     */
    code: string;
    /**
     * The name of the food type.
     */
    name: string;
};

export type FoodOrigin = {
    /**
     * The id of the origin.
     */
    id: number;
    /**
     * The name of the origin.
     */
    name: string;
};

export type LangualCode = {
    /**
     * The ID of the LanguaL code.
     */
    id: number;
    /**
     * The LanguaL code.
     */
    code: string;
    /**
     * The descriptor of the LanguaL code.
     */
    descriptor: string;
};

export type GroupedLangualCode = {
    /**
     * The children of the LanguaL code.
     */
    children: Array<LangualCode>;
    /**
     * The ID of the LanguaL code.
     */
    id: number;
    /**
     * The LanguaL code.
     */
    code: string;
    /**
     * The descriptor of the LanguaL code.
     */
    descriptor: string;
};

export type Reference = {
    /**
     * The code of the reference.
     */
    code: number;
    /**
     * The title of the reference.
     */
    title: string;
    /**
     * The type of the reference.
     */
    type: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * The authors of the reference.
     */
    authors: Array<string>;
    /**
     * The year of the reference.
     */
    year?: number;
    /**
     * Additional information of the reference.
     */
    other?: string;
    /**
     * The volume number. Only present if `type` is "article".
     */
    volume?: number;
    /**
     * The issue number. Only present if `type` is "article".
     */
    issue?: number;
    /**
     * The year of the volume. Only present if `type` is "article".
     */
    volumeYear?: number;
    /**
     * The journal where the reference was published. Only present if `type` is "article".
     */
    journalName?: string;
    /**
     * The starting page of the article. Only present if `type` is "article".
     */
    pageStart?: number;
    /**
     * The ending page of the article. Only present if `type` is "article".
     */
    pageEnd?: number;
    /**
     * The city where the reference was published.
     */
    city?: string;
};

export type Food = {
    /**
     * The ingredients of the food.
     */
    ingredients: StringTranslation;
    /**
     * The group of the food.
     */
    group: BaseFoodGroup;
    /**
     * The type of the food.
     */
    type: BaseFoodType;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * The origins of the food.
     */
    origins: Array<FoodOrigin>;
    /**
     * Array with all the LanguaL codes of the food.
     */
    langualCodes: Array<GroupedLangualCode>;
    /**
     * The nutrient measurements of the food.
     */
    nutrientMeasurements: GroupedNutrientMeasurements;
    /**
     * Array with all the referenced used in the nutrient measurements of the food.
     */
    references: Array<Reference>;
    /**
     * The common name of the food.
     */
    commonName: StringTranslation;
    /**
     * The scientific name of the food.
     */
    scientificName?: string;
    /**
     * The subspecies of the food.
     */
    subspecies?: string;
};

export type NewFoodDto = {
    /**
     * The common name of the food.
     */
    commonName: NewCommonNameDto;
    /**
     * The ingredients of the food.
     */
    ingredients?: IngredientsDto;
    /**
     * The ID of the food group.
     */
    groupId: number;
    /**
     * The ID of the food type.
     */
    typeId: number;
    /**
     * The ID of the scientific name. Should be provided if `subspeciesId` is present.
     */
    scientificNameId?: number;
    /**
     * The ID of the subspecies.
     */
    subspeciesId?: number;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * An array of origin IDs.
     */
    originIds?: Array<number>;
    /**
     * An array with all the nutrient measurements of the food.
     */
    nutrientMeasurements: Array<NewNutrientMeasurementDto>;
    /**
     * An array with all the LanguaL codes of the food.
     */
    langualCodes: Array<number>;
};

export type CommonNameUpdateDto = {
    /**
     * The common name in spanish.
     */
    es?: string;
    /**
     * The common name in english.
     */
    en?: string;
    /**
     * The common name in portuguese.
     */
    pt?: string;
};

export type NutrientMeasurementUpdateDto = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average?: number;
    /**
     * The deviation value of the measurement.
     */
    deviation?: number;
    /**
     * The minimum value of the measurement.
     */
    min?: number;
    /**
     * The maximum value of the measurement.
     */
    max?: number;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: number;
    /**
     * The data type of the measurement.
     */
    dataType?: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<number>;
};

export type FoodUpdateDto = {
    /**
     * The common name of the food.
     */
    commonName?: CommonNameUpdateDto;
    /**
     * The ingredients of the food.
     */
    ingredients?: IngredientsDto;
    /**
     * The ID of the food group.
     */
    groupId?: number;
    /**
     * The ID of the food type.
     */
    typeId?: number;
    /**
     * The ID of the scientific name.
     */
    scientificNameId?: number;
    /**
     * The ID of the subspecies.
     */
    subspeciesId?: number;
    /**
     * The strain of the food.
     */
    strain?: string;
    /**
     * The brand of the food.
     */
    brand?: string;
    /**
     * Any additional observations about the food.
     */
    observation?: string;
    /**
     * An array of origin IDs.
     */
    originIds?: Array<number>;
    /**
     * An array of nutrient measurements of the food.
     */
    nutrientMeasurements?: Array<NutrientMeasurementUpdateDto>;
    /**
     * An array of LanguaL codes of the food.
     */
    langualCodes?: Array<number>;
};

export type FoodGroup = {
    /**
     * The code of the food group.
     */
    code: string;
    /**
     * The name of the food group.
     */
    name: string;
    /**
     * The id of the food group.
     */
    id: number;
};

export type NewGroupDto = {
    /**
     * The code of the food group.
     */
    code: string;
    /**
     * The name of the food group.
     */
    name: string;
};

export type Nutrient = {
    /**
     * The ID of the nutrient.
     */
    id: number;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
};

export type Macronutrient = {
    /**
     * The ID of the nutrient.
     */
    id: number;
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
    /**
     * The nutrients that make up this macronutrient.
     */
    components: Array<Nutrient>;
};

export type Micronutrients = {
    /**
     * An array with all the vitamins.
     */
    vitamins: Array<Nutrient>;
    /**
     * An array with all the minerals.
     */
    minerals: Array<Nutrient>;
};

export type GroupedNutrients = {
    /**
     * An array with all the energy nutrients.
     */
    energy: Array<Nutrient>;
    /**
     * An array with all the macronutrients.
     */
    macronutrients: Array<Macronutrient>;
    /**
     * Object containing all the micronutrients.
     */
    micronutrients: Micronutrients;
};

export type NewNutrientDto = {
    /**
     * The type of the nutrient.
     */
    type: 'energy' | 'macronutrient' | 'component' | 'micronutrient';
    /**
     * The name of the nutrient.
     */
    name: string;
    /**
     * The measurement unit of the nutrient.
     */
    measurementUnit: string;
    /**
     * Whether the nutrient's measurements are standardized.
     */
    standardized?: boolean;
    /**
     * Additional notes about the nutrient.
     */
    note?: string;
    /**
     * The ID of the macronutrient associated with this nutrient.
     * Should only be provided if the `type` is "component".
     */
    macronutrientId?: number;
    /**
     * The type of micronutrient, if applicable.
     * Should only be provided if the `type` is "micronutrient".
     */
    micronutrientType?: 'vitamin' | 'mineral';
};

export type Origin = {
    /**
     * The ID of the parent origin. Not present if the `type` is "region".
     */
    parentId?: number;
    /**
     * The number of the region (1-indexed).
     */
    regionNumber?: number;
    /**
     * The place of the origin from north to south (0-indexed).
     */
    regionPlace?: number;
    /**
     * The type of the location. Only present if `type` is "location".
     */
    locationType?: 'city' | 'town';
    /**
     * The id of the origin.
     */
    id: number;
    /**
     * The type of the origin.
     */
    type: 'region' | 'province' | 'commune' | 'location';
    /**
     * The name of the origin.
     */
    name: string;
};

export type NewOriginDto = {
    /**
     * The name of the origin.
     */
    name: string;
    /**
     * The type of the origin.
     */
    type: 'region' | 'province' | 'commune' | 'location';
    /**
     * The ID of the parent origin. Should only be provided if `type` is not "region".
     */
    parentId?: number;
    /**
     * The region number. Should only be provided if `type` is "region".
     */
    regionNumber?: number;
    /**
     * The region place. Should only be provided if `type` is "region".
     */
    regionPlace?: number;
    /**
     * The type of the location. Should only be provided if `type` is "location".
     */
    locationType?: 'city' | 'town';
};

export type OriginWithoutId = {
    /**
     * The type of the origin.
     */
    type: 'region' | 'province' | 'commune' | 'location';
    /**
     * The name of the origin.
     */
    name: string;
    /**
     * The ID of the parent origin. Not present if the `type` is "region".
     */
    parentId?: number;
    /**
     * The number of the region (1-indexed).
     */
    regionNumber?: number;
    /**
     * The place of the origin from north to south (0-indexed).
     */
    regionPlace?: number;
    /**
     * The type of the location. Only present if `type` is "location".
     */
    locationType?: 'city' | 'town';
};

export type OriginChild = {
    /**
     * The ID of the child origin.
     */
    id: number;
    /**
     * The name of the child origin.
     */
    name: string;
    /**
     * The location type of the child origin.
     * Only present if the child origin type is "location", i.e. parent type is "commune".
     */
    type?: 'city' | 'town';
};

export type NewVolumeDto = {
    /**
     * The volume number.
     */
    volume: number;
    /**
     * The issue number.
     */
    issue: number;
    /**
     * The year of the volume.
     */
    year: number;
    /**
     * The ID of the journal. Should not be provided if `newJournal` is present.
     */
    journalId?: number;
    /**
     * The name of the new journal. Should not be provided if `journalId` is present.
     */
    newJournal?: string;
};

export type NewArticleDto = {
    /**
     * The starting page of the article.
     */
    pageStart: number;
    /**
     * The ending page of the article.
     */
    pageEnd: number;
    /**
     * The ID of the volume. Should not be provided if `newVolume` is present.
     */
    volumeId?: number;
    /**
     * The DTO for creating a new volume. Should not be provided if `volumeId` is present.
     */
    newVolume?: NewVolumeDto;
};

export type NewBatchReferenceDto = {
    /**
     * The code of the reference.
     */
    code: number;
    /**
     * The type of the reference.
     */
    type: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * The title of the reference.
     */
    title: string;
    /**
     * An array of author IDs. The length of this combined with `newAuthors` should be at least 1.
     */
    authorIds?: Array<number>;
    /**
     * An array of new author names.  The length of this combined with `authorIds` should be at least 1.
     */
    newAuthors?: Array<string>;
    /**
     * The year of the reference.
     */
    year?: number;
    /**
     * The DTO for creating a new article. Should only be provided if `type` is "article".
     */
    newArticle?: NewArticleDto;
    /**
     * The ID of the city. Should not be provided if `newCity` is present.
     */
    cityId?: number;
    /**
     * The name of the new city. Should not be provided if `cityId` is present.
     */
    newCity?: string;
    /**
     * Additional information required for website or book references. May be specified for other types as well.
     */
    other?: string;
};

export type NewBatchReferencesArrayDto = {
    /**
     * An array of new references. Codes and articles may not be repeated.
     */
    references: Array<NewBatchReferenceDto>;
};

export type NewReferenceDto = {
    /**
     * The type of the reference.
     */
    type: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * The title of the reference.
     */
    title: string;
    /**
     * An array of author IDs. The length of this combined with `newAuthors` should be at least 1.
     */
    authorIds?: Array<number>;
    /**
     * An array of new author names.  The length of this combined with `authorIds` should be at least 1.
     */
    newAuthors?: Array<string>;
    /**
     * The year of the reference.
     */
    year?: number;
    /**
     * The DTO for creating a new article. Should only be provided if `type` is "article".
     */
    newArticle?: NewArticleDto;
    /**
     * The ID of the city. Should not be provided if `newCity` is present.
     */
    cityId?: number;
    /**
     * The name of the new city. Should not be provided if `cityId` is present.
     */
    newCity?: string;
    /**
     * Additional information required for website or book references. May be specified for other types as well.
     */
    other?: string;
};

export type Author = {
    /**
     * The ID of the author.
     */
    id: number;
    /**
     * The name of the author.
     */
    name: string;
};

export type City = {
    /**
     * The ID of the city.
     */
    id: number;
    /**
     * The name of the city.
     */
    name: string;
};

export type Article = {
    /**
     * The ID of the author.
     */
    id: number;
    /**
     * The ID of the volume.
     */
    volumeId: number;
    /**
     * The starting page of the article.
     */
    pageStart: number;
    /**
     * The ending page of the article.
     */
    pageEnd: number;
};

export type JournalVolume = {
    /**
     * The ID of the author.
     */
    id: number;
    /**
     * The ID of the journal.
     */
    journalId: number;
    /**
     * The volume number.
     */
    volume: number;
    /**
     * The issue number.
     */
    issue: number;
    /**
     * The year of the volume.
     */
    year: number;
};

export type Journal = {
    /**
     * The ID of the journal.
     */
    id: number;
    /**
     * The name of the journal.
     */
    name: string;
};

export type ScientificName = {
    /**
     * The id of the scientific name.
     */
    id: number;
    /**
     * The scientific name.
     */
    name: string;
};

export type NewScientificNameDto = {
    /**
     * The name of the scientific entity.
     */
    name: string;
};

export type Subspecies = {
    /**
     * The id of the subspecies.
     */
    id: number;
    /**
     * The name of the subspecies.
     */
    name: string;
};

export type NewSubspeciesDto = {
    /**
     * The name of the subspecies.
     */
    name: string;
};

export type FoodType = {
    /**
     * The code of the food type.
     */
    code: string;
    /**
     * The name of the food type.
     */
    name: string;
    /**
     * The id of the food type.
     */
    id: number;
};

export type NewTypeDto = {
    /**
     * The code of the food type.
     */
    code: string;
    /**
     * The name of the food type.
     */
    name: string;
};

export type Language = {
    /**
     * The ID of the language.
     */
    id: number;
    /**
     * The code of the language.
     */
    code: 'es' | 'en' | 'pt';
    /**
     * The name of the language.
     */
    name: string;
};

export type XlsxFileDto = {
    file: Blob | File;
};

export type XlsxStringValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: string | null;
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: string | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxStringTranslation = {
    /**
     * String translation in spanish.
     */
    es: XlsxStringValue | null;
    /**
     * String translation in english.
     */
    en: XlsxStringValue | null;
    /**
     * String translation in portuguese.
     */
    pt: XlsxStringValue | null;
};

export type XlsxNumberValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: number | null;
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: number | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxMeasurementDataTypeValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: 'analytic' | 'calculated' | 'assumed' | 'borrowed';
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: string | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxNutrientMeasurement = {
    /**
     * The ID of the nutrient.
     */
    nutrientId: number;
    /**
     * The average value of the measurement.
     */
    average: XlsxNumberValue;
    /**
     * The deviation value of the measurement.
     */
    deviation?: XlsxNumberValue;
    /**
     * The minimum value of the measurement.
     */
    min?: XlsxNumberValue;
    /**
     * The maximum value of the measurement.
     */
    max?: XlsxNumberValue;
    /**
     * The sample size of the measurement.
     */
    sampleSize?: XlsxNumberValue;
    /**
     * An array with all the reference codes of the measurement.
     */
    referenceCodes?: Array<XlsxNumberValue>;
    /**
     * The data type of the measurement.
     */
    dataType: XlsxMeasurementDataTypeValue;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxFood = {
    /**
     * The code of the food.
     */
    code: XlsxStringValue;
    /**
     * The common name of the food.
     */
    commonName: XlsxStringTranslation;
    /**
     * The ingredients of the food.
     */
    ingredients: XlsxStringTranslation;
    /**
     * The group of the food.
     */
    group: XlsxNumberValue;
    /**
     * The type of the food.
     */
    type: XlsxNumberValue;
    /**
     * The scientific name of the food.
     */
    scientificName?: XlsxNumberValue;
    /**
     * The subspecies of the food.
     */
    subspecies?: XlsxNumberValue;
    /**
     * The strain of the food.
     */
    strain?: XlsxStringValue;
    /**
     * The brand of the food.
     */
    brand?: XlsxStringValue;
    /**
     * The origins of the food.
     */
    origins: Array<XlsxNumberValue>;
    /**
     * Any additional observations about the food.
     */
    observation?: XlsxStringValue;
    /**
     * Array with all the LanguaL codes of the food.
     */
    langualCodes: Array<XlsxNumberValue>;
    /**
     * The nutrient measurements of the food.
     */
    nutrientMeasurements: Array<XlsxNutrientMeasurement>;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxReferenceTypeValue = {
    /**
     * Parsed value from the XLS(X) file. `null` if it wasn't able to be parsed or if `raw` is empty string.
     */
    parsed: 'report' | 'thesis' | 'article' | 'website' | 'book';
    /**
     * Raw value obtained from the XLS(X) file.
     */
    raw: string;
    /**
     * Old value stored in the database. May be `null`.
     */
    old?: string | null;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type XlsxReference = {
    /**
     * The code of the reference.
     */
    code: XlsxNumberValue;
    /**
     * The title of the reference.
     */
    title: XlsxStringValue;
    /**
     * The type of the reference.
     */
    type: XlsxReferenceTypeValue;
    /**
     * The authors of the reference.
     */
    authors: Array<XlsxNumberValue>;
    /**
     * The year of the reference.
     */
    year?: XlsxNumberValue;
    /**
     * Additional information of the reference.
     */
    other?: XlsxStringValue;
    /**
     * The volume number.
     */
    volume?: XlsxNumberValue;
    /**
     * The issue number.
     */
    issue?: XlsxNumberValue;
    /**
     * The year of the volume.
     */
    volumeYear?: XlsxNumberValue;
    /**
     * The journal where the reference was published.
     */
    journal?: XlsxNumberValue;
    /**
     * The starting page of the article.
     */
    pageStart?: XlsxNumberValue;
    /**
     * The ending page of the article.
     */
    pageEnd?: XlsxNumberValue;
    /**
     * The city where the reference was published.
     */
    city?: XlsxNumberValue;
    /**
     * Flags of this value, composed of 3 bits in the following order: (`updated`, `new`, `valid`).
     * Note: `updated` and `new` are mutually exclusive.
     *
     * Flag values:
     * - 0 = 0b000 => invalid
     * - 1 = 0b001 => valid
     * - 2 = 0b010 => new, invalid
     * - 3 = 0b011 => new, valid
     * - 4 = 0b100 => updated, invalid
     * - 5 = 0b101 => updated, valid
     */
    flags: number;
};

export type ParseXlsxResult = {
    /**
     * Array with all the foods parsed from the XLS(X) file.
     */
    foods: Array<XlsxFood>;
    /**
     * Array with all the foods parsed from the XLS(X) file.
     */
    references: Array<XlsxReference>;
};

export type LoginData = {
    body: AdminCredentialsDto;
    path?: never;
    query?: never;
    url: '/auth/login';
};

export type LoginErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Invalid username or password.
     */
    401: HttpException;
    /**
     * Too many attempts.
     */
    429: HttpException;
};

export type LoginError = LoginErrors[keyof LoginErrors];

export type LoginResponses = {
    /**
     * Logged in successfully.
     */
    201: unknown;
};

export type LogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/logout';
};

export type LogoutErrors = {
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type LogoutError = LogoutErrors[keyof LogoutErrors];

export type LogoutResponses = {
    /**
     * Logged out successfully.
     */
    204: void;
};

export type LogoutResponse = LogoutResponses[keyof LogoutResponses];

export type GetSessionInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/me';
};

export type GetSessionInfoErrors = {
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
};

export type GetSessionInfoError = GetSessionInfoErrors[keyof GetSessionInfoErrors];

export type GetSessionInfoResponses = {
    /**
     * Got session information successfully.
     */
    200: SessionInfo;
};

export type GetSessionInfoResponse = GetSessionInfoResponses[keyof GetSessionInfoResponses];

export type DeleteAdminData = {
    body?: never;
    path: {
        /**
         * The username of the admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}';
};

export type DeleteAdminErrors = {
    /**
     * Validation errors (params).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type DeleteAdminError = DeleteAdminErrors[keyof DeleteAdminErrors];

export type DeleteAdminResponses = {
    /**
     * Admin deleted successfully.
     */
    204: void;
};

export type DeleteAdminResponse = DeleteAdminResponses[keyof DeleteAdminResponses];

export type CreateAdminData = {
    body: NewAdminDto;
    path: {
        /**
         * The username of the new admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}';
};

export type CreateAdminErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Admin already exists.
     */
    409: HttpException;
};

export type CreateAdminError = CreateAdminErrors[keyof CreateAdminErrors];

export type CreateAdminResponses = {
    /**
     * Admin created successfully.
     */
    201: unknown;
};

export type DeleteSessionData = {
    body?: never;
    path: {
        /**
         * The username of the admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}/session';
};

export type DeleteSessionErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type DeleteSessionError = DeleteSessionErrors[keyof DeleteSessionErrors];

export type DeleteSessionResponses = {
    /**
     * Session token deleted successfully.
     */
    204: void;
};

export type DeleteSessionResponse = DeleteSessionResponses[keyof DeleteSessionResponses];

export type GetSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/admins/{username}/session';
};

export type GetSessionErrors = {
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
};

export type GetSessionError = GetSessionErrors[keyof GetSessionErrors];

export type GetSessionResponses = {
    /**
     * Session token validated successfully.
     */
    200: unknown;
};

export type CreateSessionData = {
    body: NewSessionDto;
    path: {
        /**
         * The username of the admin.
         * It must be a string of 8-32 alphanumeric characters, underscores, or dots.
         */
        username: string;
    };
    query?: never;
    url: '/admins/{username}/session';
};

export type CreateSessionErrors = {
    /**
     * Validation errors (params or body).
     */
    400: HttpException;
    /**
     * Password is incorrect.
     */
    401: HttpException;
    /**
     * Admin doesn't exist.
     */
    404: HttpException;
};

export type CreateSessionError = CreateSessionErrors[keyof CreateSessionErrors];

export type CreateSessionResponses = {
    /**
     * Session token created successfully.
     */
    201: SessionToken;
};

export type CreateSessionResponse = CreateSessionResponses[keyof CreateSessionResponses];

export type GetFoodsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the food.
         */
        name?: string;
        /**
         * An array of region IDs.
         */
        regions?: Array<number>;
        /**
         * An array of group IDs.
         */
        groups?: Array<number>;
        /**
         * An array of type IDs.
         */
        types?: Array<number>;
        /**
         * An array of nutrient IDs.
         */
        nutrients?: Array<number>;
        /**
         * An array of comparison operators.
         */
        operators?: Array<'<' | '<=' | '=' | '>=' | '>'>;
        /**
         * An array of values for nutrient filters.
         */
        values?: Array<number>;
    };
    url: '/foods';
};

export type GetFoodsErrors = {
    /**
     * <br/>Either one of the following:<br/>– Some regions don't exist.<br/>– Some food groups don't exist.<br/>– Some food types don't exist.<br/>– Some nutrients don't exist.<br/>
     */
    404: HttpException;
};

export type GetFoodsError = GetFoodsErrors[keyof GetFoodsErrors];

export type GetFoodsResponses = {
    /**
     * Successfully retrieved foods.
     */
    200: Array<BaseFood>;
};

export type GetFoodsResponse = GetFoodsResponses[keyof GetFoodsResponses];

export type BatchCreateFoodsData = {
    body: NewBatchFoodsArrayDto;
    path?: never;
    query?: never;
    url: '/foods';
};

export type BatchCreateFoodsErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>– Food group doesn't exist.<br/>– Food type doesn't exist.<br/>– Scientific name doesn't exist.<br/>– Subspecies doesn't exist.<br/>– Some origins don't exist.<br/>– Some LanguaL codes don't exist.<br/>– Nutrient doesn't exist.<br/>– Some references don't exist.<br/>
     */
    404: HttpException;
    /**
     * Food already exists.
     */
    409: HttpException;
};

export type BatchCreateFoodsError = BatchCreateFoodsErrors[keyof BatchCreateFoodsErrors];

export type BatchCreateFoodsResponses = {
    /**
     * Foods created successfully.
     */
    201: unknown;
};

export type CompareFoodsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of food codes.
         */
        codes?: Array<string>;
    };
    url: '/foods/compare';
};

export type CompareFoodsResponses = {
    200: Array<FoodWithOnlyMeasurements>;
};

export type CompareFoodsResponse = CompareFoodsResponses[keyof CompareFoodsResponses];

export type GetFoodData = {
    body?: never;
    path: {
        /**
         * The code of the food.
         */
        code: string;
    };
    query?: never;
    url: '/foods/{code}';
};

export type GetFoodErrors = {
    /**
     * Food doesn't exist.
     */
    404: HttpException;
};

export type GetFoodError = GetFoodErrors[keyof GetFoodErrors];

export type GetFoodResponses = {
    /**
     * Successfully retrieved food.
     */
    200: Food;
};

export type GetFoodResponse = GetFoodResponses[keyof GetFoodResponses];

export type UpdateFoodData = {
    body: FoodUpdateDto;
    path: {
        /**
         * The code of the food.
         */
        code: string;
    };
    query?: never;
    url: '/foods/{code}';
};

export type UpdateFoodErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Food doesn't exist.<br/>- Food group doesn't exist.<br/>- Food type doesn't exist.<br/>- Scientific name doesn't exist.<br/>- Subspecies doesn't exist.<br/>- Some origins don't exist.<br/>- Some LanguaL codes don't exist.<br/>- Nutrient doesn't exist.<br/>- Some references don't exist.<br/>
     */
    404: HttpException;
};

export type UpdateFoodError = UpdateFoodErrors[keyof UpdateFoodErrors];

export type UpdateFoodResponses = {
    /**
     * Food updated successfully.
     */
    200: unknown;
};

export type CreateFoodData = {
    body: NewFoodDto;
    path: {
        /**
         * The code of the new food.
         */
        code: string;
    };
    query?: never;
    url: '/foods/{code}';
};

export type CreateFoodErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Food group doesn't exist.<br/>- Food type doesn't exist.<br/>- Scientific name doesn't exist.<br/>- Subspecies doesn't exist.<br/>- Some origins don't exist.<br/>- Some LanguaL codes don't exist.<br/>- Nutrient doesn't exist.<br/>- Some references don't exist.<br/>
     */
    404: HttpException;
    /**
     * Food already exists.
     */
    409: HttpException;
};

export type CreateFoodError = CreateFoodErrors[keyof CreateFoodErrors];

export type CreateFoodResponses = {
    /**
     * Food created successfully.
     */
    201: unknown;
};

export type GetFoodGroupsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/groups';
};

export type GetFoodGroupsResponses = {
    /**
     * Successfully retrieved food groups.
     */
    200: Array<FoodGroup>;
};

export type GetFoodGroupsResponse = GetFoodGroupsResponses[keyof GetFoodGroupsResponses];

export type CreateFoodGroupData = {
    body: NewGroupDto;
    path?: never;
    query?: never;
    url: '/groups';
};

export type CreateFoodGroupErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Food group already exists.
     */
    409: HttpException;
};

export type CreateFoodGroupError = CreateFoodGroupErrors[keyof CreateFoodGroupErrors];

export type CreateFoodGroupResponses = {
    /**
     * Food group created successfully.
     */
    201: unknown;
};

export type GetLangualCodesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/langual-codes';
};

export type GetLangualCodesResponses = {
    /**
     * Successfully retrieved LanguaL codes.
     */
    200: Array<LangualCode>;
};

export type GetLangualCodesResponse = GetLangualCodesResponses[keyof GetLangualCodesResponses];

export type GetGroupedLangualCodesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/langual-codes/grouped';
};

export type GetGroupedLangualCodesResponses = {
    /**
     * Successfully retrieved LanguaL codes grouped by parent.
     */
    200: Array<GroupedLangualCode>;
};

export type GetGroupedLangualCodesResponse = GetGroupedLangualCodesResponses[keyof GetGroupedLangualCodesResponses];

export type GetNutrientsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/nutrients';
};

export type GetNutrientsResponses = {
    /**
     * Successfully retrieved nutrients.
     */
    200: GroupedNutrients;
};

export type GetNutrientsResponse = GetNutrientsResponses[keyof GetNutrientsResponses];

export type CreateNutrientData = {
    body: NewNutrientDto;
    path?: never;
    query?: never;
    url: '/nutrients';
};

export type CreateNutrientErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Macronutrient doesn't exist.
     */
    404: HttpException;
    /**
     * Nutrient already exists.
     */
    409: HttpException;
};

export type CreateNutrientError = CreateNutrientErrors[keyof CreateNutrientErrors];

export type CreateNutrientResponses = {
    /**
     * Nutrient created successfully.
     */
    201: unknown;
};

export type GetOriginsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the origin.
         */
        name?: string;
    };
    url: '/origins';
};

export type GetOriginsResponses = {
    /**
     * Successfully retrieved origins.
     */
    200: Array<Origin>;
};

export type GetOriginsResponse = GetOriginsResponses[keyof GetOriginsResponses];

export type CreateOriginData = {
    body: NewOriginDto;
    path?: never;
    query?: never;
    url: '/origins';
};

export type CreateOriginErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Parent origin doesn't exist.
     */
    404: HttpException;
    /**
     * Origin already exists.
     */
    409: HttpException;
};

export type CreateOriginError = CreateOriginErrors[keyof CreateOriginErrors];

export type CreateOriginResponses = {
    /**
     * Origin created successfully.
     */
    201: unknown;
};

export type GetOriginData = {
    body?: never;
    path: {
        /**
         * The ID of the origin.
         */
        id: number;
    };
    query?: never;
    url: '/origins/{id}';
};

export type GetOriginErrors = {
    /**
     * Validation errors (params).
     */
    400: HttpException;
    /**
     * Origin doesn't exist.
     */
    404: HttpException;
};

export type GetOriginError = GetOriginErrors[keyof GetOriginErrors];

export type GetOriginResponses = {
    /**
     * Successfully retrieved origin.
     */
    200: OriginWithoutId;
};

export type GetOriginResponse = GetOriginResponses[keyof GetOriginResponses];

export type GetOriginChildrenData = {
    body?: never;
    path: {
        /**
         * The ID of the origin.
         */
        id: number;
    };
    query?: never;
    url: '/origins/{id}/children';
};

export type GetOriginChildrenErrors = {
    /**
     * Validation errors (params).
     */
    400: HttpException;
    /**
     * Origin doesn't exist.
     */
    404: HttpException;
};

export type GetOriginChildrenError = GetOriginChildrenErrors[keyof GetOriginChildrenErrors];

export type GetOriginChildrenResponses = {
    /**
     * Successfully retrieved origin children.
     */
    200: Array<OriginChild>;
};

export type GetOriginChildrenResponse = GetOriginChildrenResponses[keyof GetOriginChildrenResponses];

export type GetReferencesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The title of the reference.
         */
        title?: string;
        /**
         * An array of author IDs.
         */
        authors?: Array<number>;
        /**
         * An array of journal IDs.
         */
        journals?: Array<number>;
        /**
         * An array of city IDs.
         */
        cities?: Array<number>;
    };
    url: '/references';
};

export type GetReferencesErrors = {
    /**
     * Validation errors (query).
     */
    400: HttpException;
    /**
     * <br/>Either one of the following:<br/>– Some authors don't exist.<br/>– Some cities don't exist.<br/>– Some journals don't exist.<br/>
     */
    404: HttpException;
};

export type GetReferencesError = GetReferencesErrors[keyof GetReferencesErrors];

export type GetReferencesResponses = {
    /**
     * Successfully retrieved references.
     */
    200: Array<Reference>;
};

export type GetReferencesResponse = GetReferencesResponses[keyof GetReferencesResponses];

export type BatchCreateReferencesData = {
    body: NewBatchReferencesArrayDto;
    path?: never;
    query?: never;
    url: '/references';
};

export type BatchCreateReferencesErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Some authors don't exist.<br/>- City doesn't exist.<br/>- Volume doesn't exist.<br/>- Journal doesn't exist.<br/>
     */
    404: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Reference already exists.<br/>- Some authors already exist.<br/>- City already exists.<br/>- Volume already exists.<br/>- Journal already exists.<br/>
     */
    409: HttpException;
};

export type BatchCreateReferencesError = BatchCreateReferencesErrors[keyof BatchCreateReferencesErrors];

export type BatchCreateReferencesResponses = {
    /**
     * References created successfully.
     */
    201: unknown;
};

export type CreateReferenceData = {
    body: NewReferenceDto;
    path: {
        /**
         * The code of the reference.
         */
        code: number;
    };
    query?: never;
    url: '/references/{code}';
};

export type CreateReferenceErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Some authors don't exist.<br/>- City doesn't exist.<br/>- Volume doesn't exist.<br/>- Journal doesn't exist.<br/>
     */
    404: HttpException;
    /**
     * <br/>Either one of the following:<br/>- Reference already exists.<br/>- Some authors already exist.<br/>- City already exists.<br/>- Volume already exists.<br/>- Journal already exists.<br/>
     */
    409: HttpException;
};

export type CreateReferenceError = CreateReferenceErrors[keyof CreateReferenceErrors];

export type CreateReferenceResponses = {
    /**
     * Reference created successfully.
     */
    201: unknown;
};

export type GetAuthorsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/authors';
};

export type GetAuthorsResponses = {
    /**
     * Successfully retrieved authors.
     */
    200: Array<Author>;
};

export type GetAuthorsResponse = GetAuthorsResponses[keyof GetAuthorsResponses];

export type GetCitiesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/cities';
};

export type GetCitiesResponses = {
    /**
     * Successfully retrieved cities.
     */
    200: Array<City>;
};

export type GetCitiesResponse = GetCitiesResponses[keyof GetCitiesResponses];

export type GetArticlesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/articles';
};

export type GetArticlesResponses = {
    200: Array<Article>;
};

export type GetArticlesResponse = GetArticlesResponses[keyof GetArticlesResponses];

export type GetJournalVolumesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/journal-volumes';
};

export type GetJournalVolumesResponses = {
    200: Array<JournalVolume>;
};

export type GetJournalVolumesResponse = GetJournalVolumesResponses[keyof GetJournalVolumesResponses];

export type GetJournalsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/references/journals';
};

export type GetJournalsResponses = {
    /**
     * Successfully retrieved journals.
     */
    200: Array<Journal>;
};

export type GetJournalsResponse = GetJournalsResponses[keyof GetJournalsResponses];

export type GetScientificNamesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/scientific-names';
};

export type GetScientificNamesResponses = {
    /**
     * Successfully retrieved scientific names.
     */
    200: Array<ScientificName>;
};

export type GetScientificNamesResponse = GetScientificNamesResponses[keyof GetScientificNamesResponses];

export type CreateScientificNameData = {
    body: NewScientificNameDto;
    path?: never;
    query?: never;
    url: '/scientific-names';
};

export type CreateScientificNameErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Scientific name already exists.
     */
    409: HttpException;
};

export type CreateScientificNameError = CreateScientificNameErrors[keyof CreateScientificNameErrors];

export type CreateScientificNameResponses = {
    /**
     * Scientific name created successfully.
     */
    201: unknown;
};

export type GetSubspeciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/subspecies';
};

export type GetSubspeciesResponses = {
    /**
     * Successfully retrieved subspecies.
     */
    200: Array<Subspecies>;
};

export type GetSubspeciesResponse = GetSubspeciesResponses[keyof GetSubspeciesResponses];

export type CreateSubspeciesData = {
    body: NewSubspeciesDto;
    path?: never;
    query?: never;
    url: '/subspecies';
};

export type CreateSubspeciesErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Subspecies already exists.
     */
    409: HttpException;
};

export type CreateSubspeciesError = CreateSubspeciesErrors[keyof CreateSubspeciesErrors];

export type CreateSubspeciesResponses = {
    /**
     * Subspecies created successfully.
     */
    201: unknown;
};

export type GetFoodTypesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/types';
};

export type GetFoodTypesResponses = {
    /**
     * Successfully retrieved food types.
     */
    200: Array<FoodType>;
};

export type GetFoodTypesResponse = GetFoodTypesResponses[keyof GetFoodTypesResponses];

export type CreateFoodTypeData = {
    body: NewTypeDto;
    path?: never;
    query?: never;
    url: '/types';
};

export type CreateFoodTypeErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
    /**
     * Food type already exists.
     */
    409: HttpException;
};

export type CreateFoodTypeError = CreateFoodTypeErrors[keyof CreateFoodTypeErrors];

export type CreateFoodTypeResponses = {
    /**
     * Food type created successfully.
     */
    201: unknown;
};

export type GetLanguagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/languages';
};

export type GetLanguagesResponses = {
    /**
     * Successfully retrieved languages.
     */
    200: Array<Language>;
};

export type GetLanguagesResponse = GetLanguagesResponses[keyof GetLanguagesResponses];

export type GetXlsxData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * An array of food codes.
         */
        codes?: Array<string>;
        /**
         * The language in which to get the food data.
         */
        lang?: 'es' | 'en' | 'pt';
    };
    url: '/xlsx';
};

export type GetXlsxErrors = {
    /**
     * Validation errors (query).
     */
    400: HttpException;
};

export type GetXlsxError = GetXlsxErrors[keyof GetXlsxErrors];

export type GetXlsxResponses = {
    /**
     * XLSX file with food and references
     */
    200: unknown;
};

export type ParseXlsxData = {
    /**
     * The XLS(X) file.
     */
    body: XlsxFileDto;
    path?: never;
    query?: never;
    url: '/xlsx';
};

export type ParseXlsxErrors = {
    /**
     * Validation errors (body).
     */
    400: HttpException;
    /**
     * Session token is missing or invalid.
     */
    401: HttpException;
};

export type ParseXlsxError = ParseXlsxErrors[keyof ParseXlsxErrors];

export type ParseXlsxResponses = {
    /**
     * Parsed XLS(X) file contents successfully.
     */
    200: ParseXlsxResult;
    /**
     * *Never returned. Automatically generated by Swagger.*
     */
    201: unknown;
};

export type ParseXlsxResponse = ParseXlsxResponses[keyof ParseXlsxResponses];

export type ClientOptions = {
    baseUrl: `${string}://api` | (string & {});
};